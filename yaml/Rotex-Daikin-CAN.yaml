############################### Version 1.4.0 #####################################
substitutions:
  rx_pin: GPIO48
  tx_pin: GPIO47
  interval_time: 20s

esphome:
    name: rotex
    friendly_name: Rotex
    includes:
        - include/utils.h
        - include/request.h
        - include/${heatpump_model}.h
        - src/utils.cpp
    platformio_options:
        build_unflags:
            - "-std=gnu++11"
        build_flags:
            - "-std=gnu++17"
    on_loop:
      then:
      - lambda: |-
          data_requests.sendNextPendingRequest(id(can_bus));

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: arduino

globals:
  - id: backup_dhw
    type: int

  - id: interval_active
    type: bool
    restore_value: yes
    initial_value: "true"

# Enable logging
logger:
  #level: VERBOSE
  level: INFO

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  platform: esphome
  password: !secret ota_password

web_server:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Rotex Fallback Hotspot"
    password: "H3jGqANSa7aL"

captive_portal:

<<: !include sensors.yaml

############################## Text Sensoren ########################################
text_sensor:
  - platform: template
    name: "Betriebsmodus"
    id: text_betriebsmodus
    lambda: |-
      switch ((uint32_t)id(Betriebsmodus).state)
      {
      case 0:  return {"Notbetrieb"};
      case 1:  return {"Bereitschaft"};
      case 3:  return {"Heizen"};
      case 4:  return {"Absenken"};
      case 5:  return {"Sommer"};
      case 11: return {"Automatik 1"};
      case 12: return {"Automatik 2"};
      case 17: return {"Kühlen"};
      default:
        return {"Unknown"};
      }

  - platform: template
    name: "SG-Modus"
    id: text_sg_modus
    lambda: |-
      switch ((uint32_t)id(SGModus).state)
      {
      case 0: return {"Aus"};
      case 1: return {"SG Modus 1"};
      case 2: return {"SG Modus 2"};
      default:
        return {"Unknown"};
      }

  - platform: template
    name: "Smart-Grid"
    id: text_smartgrid
    lambda: |-
      switch ((uint32_t)id(Smartgrid).state)
      {
      case 0: return {"Aus"};
      case 1: return {"An"};
      default:
        return {"Unknown"};
      }

  - platform: template
    name: "Betriebsart"
    id: text_betriebsart
    lambda: |-
      switch ((uint32_t)id(Betriebsart).state)
      {
      case 0: return {"Standby"};
      case 1: return {"Heizen"};
      case 2: return {"Kühlen"};
      case 3: return {"Abtauen"};
      case 4: return {"Warmwasserbereitung"};
      default:
        return {"Unknown"};
      }

  - platform: template
    name: "Fehlercode"
    id: text_fehler
    lambda: |-
      switch ((uint32_t)id(Fehlercode).state)
      {
      case 0: return {"kein Fehler"};
      case 9001: return {"E9001 Rücklauffühler Handbuch S.60"};
      case 9002: return {"E9002 Vorlauffühler Handbuch S.60"};
      case 9003: return {"E9003 Frostschutzfunktion Handbuch S.60"};
      case 9004: return {"E9004 Durchfluss Handbuch S.61"};
      case 9005: return {"E9005 Vorlauftemperaturfühler Handbuch S.60"};
      case 9006: return {"E9006 Vorlauftemperaturfühler Handbuch S.60"};
      case 9007: return {"E9007 Platine IG defekt Handbuch S.60"};
      case 9008: return {"E9008 Kältemitteltemperatur außerhalb des Bereiches Handbuch S.60"};
      case 9009: return {"E9009 STB Fehler Handbuch S.60"};
      case 9010: return {"E9010 STB Fehler Handbuch S.60"};
      case 9011: return {"E9011 Fehler Flowsensor Handbuch S.60"};
      case 9012: return {"E9012 Fehler Vorlauffühler Handbuch S.60"};
      case 9013: return {"E9013 Platine AG defekt Handbuch S.60"};
      case 9014: return {"E9014 P-Kältemittel hoch Handbuch S.61"};
      case 9015: return {"E9015 P-Kältemittel niedrig Handbuch S.61"};
      case 9016: return {"E9016 Lastschutz Verdichter Handbuch S.61"};
      case 9017: return {"E9017 Ventilator blockiert Handbuch S.61"};
      case 9018: return {"E9018 Expansionsventil Handbuch S.61"};
      case 9019: return {"E9019 Warmwassertemperatur > 85°C Handbuch S.61"};
      case 9020: return {"E9020 T-Verdampfer hoch Handbuch S.61"};
      case 9021: return {"E9021 HPS-System Handbuch S.61"};
      case 9022: return {"E9022 Fehler AT-Fühler Handbuch S.62"};
      case 9023: return {"E9023 Fehler WW-Fühler Handbuch S.62"};
      case 9024: return {"E9024 Drucksensor Handbuch S.62"};
      case 9025: return {"E9025 Fehler Rücklauffühler Handbuch S.62"};
      case 9026: return {"E9026 Drucksensor Handbuch S.62"};
      case 9027: return {"E9027 Aircoil-Fühler Defrost Handbuch S.62"};
      case 9028: return {"E9028 Aircoil-Fühler temp Handbuch S.62"};
      case 9029: return {"E9029 Fehler Kältefühler AG handbuch S.62"};
      case 9030: return {"E9030 Defekt elektrisch Handbuch S.63"};
      case 9031: return {"E9031 Defekt elektrisch Handbuch S.63"};
      case 9032: return {"E9032 Defekt elektrisch Handbuch S.63"};
      case 9033: return {"E9033 Defekt elektrisch Handbuch S.63"};
      case 9034: return {"E9034 Defekt elektrisch Handbuch S.63"};
      case 9035: return {"E9035 Platine AG defekt Handbuch S.63"};
      case 9036: return {"E9036 Defekt elektrisch Handbuch S.63"};
      case 9037: return {"E9037 Einstellung Leistung Handbuch S.63"};
      case 9038: return {"E9038 Kältemittel Leck Handbuch S.64"};
      case 9039: return {"E9039 Unter/Überspannung Handbuch S.64"};
      case 9041: return {"E9041 Übertragungsfehler Handbuch S.64"};
      case 9042: return {"E9042 Übertragungsfehler Handbuch S.64"};
      case 9043: return {"E9043 Übertragungsfehler Handbuch S.64"};
      case 9044: return {"E9044 Übertragungsfehler Handbuch S.64"};
      case 75: return {"E75 Fehler Außentemperaturfühler Handbuch S.64"};
      case 76: return {"E76 Fehler Speichertemperaturfühler Handbuch S.64"};
      case 81: return {"E81 Kommunikationsfehler Rocon Handbuch S.64"};
      case 88: return {"E88 Kommunikationsfehler Rocon Handbuch S.6"};
      case 91: return {"E91 Kommunikationsfehler Rocon Handbuch S.6"};
      case 128: return {"E128 Fehler Rücklauftemperaturfühler Handbuch S.64"};
      case 129: return {"E129 Fehler Drucksensor Handbuch S.64"};
      case 198: return {"E198 Durchflussmessung nicht plausibel Handbuch S.65"};
      case 200: return {"E200 Kommunikationsfehler Handbuch S.65"};
      case 8005: return {"E8005 Wasserdruck in Heizungsanlage zu gering Handbuch S.65"};
      case 8100: return {"E8100 Kommunikation Handbuch S.65"};
      case 9000: return {"E9000 Interne vorübergehende Meldung Handbuch S65"};
      case 8006: return {"W8006 Warnung Druckverlust Handbuch S.65"};
      case 8007: return {"W8007 wasserdruck in Anlage zu hoch Handbuch S.65"};
      default:
        return {"Unknown"};
      }

  - platform: template
    name: "Status Kesselpumpe"
    id: text_status2
    lambda: |-
      switch ((uint32_t)id(status_kessel).state)
      {
      case 0: return {"Aus"};
      case 1: return {"An"};
      default: return {"Unknown"};
      }

  - platform: template
    name: "Status Kompressor"
    id: text_status3
    lambda: |-
      switch ((uint32_t)id(status_kompressor).state)
      {
      case 0: return {"Aus"};
      case 1: return {"An"};
      default: return {"Unknown"};
      }

  - platform: template
    name: "HK-Funktion"
    id: text_hk_funktion
    lambda: |-
      switch ((uint32_t)id(hk_funktion).state)
      {
      case 0: return {"Witterungsgeführt"};
      case 1: return {"Fest"};
      default: return {"Unknown"};
      }

  - platform: wifi_info
    ip_address:
      name: ESP IP Address
    ssid:
      name: ESP Connected SSID

################################ Button und Switch ##############################################

button:
  - platform: template
    name: Warmwasser bereiten
    id: ww_button
    icon: "mdi:water-boiler"
    on_press:
      then:
        - globals.set:
            id: backup_dhw
            value: !lambda return int(id(t_ww_soll).state * 10);
        - canbus.send:
            can_id: 0x680
            data: [0x30, 0x00, 0x13, 0x02, 0xBC, 0x00, 0x00] # 70 Grad Grundeinstellung
        - delay: 10s
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              uint16_t temperature = (uint16_t)id(backup_dhw); // Convert to int16be
              uint8_t high_byte = temperature >> 8;
              uint8_t low_byte = temperature & 0xFF;
              return {0x30, 0x00, 0x13, high_byte, low_byte, 0x00, 0x00};
        - logger.log: CAN Nachricht wurde gesendet

  - platform: restart
    name: "Rotex ESP Restart"

switch:
  - platform: template
    name: "Intervall Abfrage"
    optimistic: true
    turn_on_action:
      - globals.set:
          id: interval_active
          value: "true"
    turn_off_action:
      - globals.set:
          id: interval_active
          value: "false"
  - platform: template
    name: "CAN Requests senden"
    id: send_can_requests
    optimistic: true

text:
  - platform: template
    id: log_filter_text
    name: "Log Filter"
    mode: text
    optimistic: true

  - platform: template
    name: "CAN message request"
    id: can_message_request
    mode: text
    set_action:
      - lambda: |-
          if (Utils::is_number(x)) {
            data_requests.sendRequest(id(can_bus), std::stoi(x));
          }

#switch:
# - platform: gpio
#  name: Heizen Thermostat
# pin: GPIO36

# - platform: gpio
#  name: Kühlen Thermostat
# pin: GPIO37
############################### Number (Slidermodus) ###############################################
number:
  - platform: template
    name: "Update Interval"
    id: update_interval
    optimistic: true
    mode: box
    min_value: 0
    max_value: 600000 # 10 minutes
    step: 1.0
    initial_value: 20000

  ##### Raumsoll 1
  - platform: template
    name: "Raumsoll 1 Einstellen"
    id: r_soll
    optimistic: true
    mode: box
    min_value: 15
    max_value: 25
    step: 0.1
    initial_value: 19
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0x05, high_byte, low_byte, 0x00, 0x00 };

  #### Heizkurve

  - platform: template
    name: "Heizkurve Einstellen"
    id: set_heizkurve
    optimistic: true
    mode: box
    min_value: 0
    max_value: 2.55
    step: 0.01
    initial_value: 0.48
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t hk = (uint16_t)(x * 100); // Convert to int16be
            uint8_t high_byte = hk >> 8;
            uint8_t low_byte = hk & 0xFF;
            return { 0x30, 0x00, 0xFA, 0x01, 0x0E, high_byte, low_byte };

  ##### Warmwasser
  - platform: template
    name: "WW Einstellen"
    id: ww_soll
    optimistic: true
    mode: box
    min_value: 35
    max_value: 70
    step: 1
    initial_value: 45
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0x13, high_byte, low_byte, 0x00, 0x00 };

  ##### Min VL
  - platform: template
    name: "Min VL Einstellen"
    id: min_vl_set
    optimistic: true
    mode: box
    min_value: 25
    max_value: 40
    step: 1
    initial_value: 25
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0xFA, 0x01, 0x2B, high_byte, low_byte };

  ##### Max VL Set
  - platform: template
    name: "Max VL Einstellen"
    id: max_vl_set
    optimistic: true
    mode: box
    min_value: 25
    max_value: 60
    step: 1
    initial_value: 35
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0x28, high_byte, low_byte, 0x00, 0x00, };

  ##### T Vorlauf Tag Set
  - platform: template
    name: "T Vorlauf Tag Einstellen"
    id: t_vorlauf_tag_set
    optimistic: true
    mode: box
    min_value: 25
    max_value: 60
    step: 1
    initial_value: 35
    unit_of_measurement: "°C"
    icon: "mdi:thermometer-lines"
    device_class: "temperature"
    set_action:
      - delay: 250ms
      - canbus.send:
          can_id: 0x680
          data: !lambda |-
            uint16_t temperature = (uint16_t)(x * 10); // Convert to int16be
            uint8_t high_byte = temperature >> 8;
            uint8_t low_byte = temperature & 0xFF;
            return { 0x30, 0x00, 0xFA,  0x01, 0x29, high_byte, low_byte, };

####################### Select Tasten ###############################

#Set Betriebsmodus
select:
  - platform: template
    name: "Betriebsmodus setzen"
    id: betrieb
    optimistic: true
    options:
      - "Heizen"
      - "Bereitschaft"
      - "Absenken"
      - "Sommer"
      - "Kühlen"
      - "Automatik 1"
      - "Automatik 2"
    initial_option: Heizen
    set_action:
      then:
        - delay: 250ms
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              static const std::map<std::string, uint8_t> mode_map = {
                {"Heizen", 3},
                {"Bereitschaft", 1},
                {"Absenken", 4},
                {"Sommer", 5},
                {"Kühlen", 17},
                {"Automatik 1", 11},
                {"Automatik 2", 12}
              };
              return {0x30, 0x00, 0xFA, 0x01, 0x12, mode_map.at(x), 0x00};

  #Set HK Funktion

  - platform: template
    name: "HK Funktion"
    id: hk
    optimistic: true
    options:
      - "Witterungsgeführt"
      - "Fest"
    initial_option: Witterungsgeführt
    set_action:
      then:
        - delay: 250ms
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              static const std::map<std::string, uint8_t> mode_map = {
                {"Witterungsgeführt", 0},
                {"Fest", 1}
              };
              return {0x30, 0x00, 0xFA, 0x01, 0x41, 0x00, mode_map.at(x)};

  #Set SG Funktion

  - platform: template
    name: "SG Modus"
    id: sg
    optimistic: true
    options:
      - "Aus"
      - "SG Modus 1"
      - "SG Modus 2"
    initial_option: Aus
    set_action:
      then:
        - delay: 250ms
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              static const std::map<std::string, uint8_t> mode_map = {
                {"Aus", 0},
                {"SG Modus 1", 1},
                {"SG Modus 2", 2}
              };
              return {0x30, 0x00, 0xFA, 0x06, 0x94, 0x00, mode_map.at(x)};

  #Set Smart Grid

  - platform: template
    name: "Smart Grid"
    id: smartgrid
    optimistic: true
    options:
      - "Aus"
      - "An"
    initial_option: Aus
    set_action:
      then:
        - delay: 250ms
        - canbus.send:
            can_id: 0x680
            data: !lambda |-
              static const std::map<std::string, uint8_t> mode_map = {
                {"Aus", 0},
                {"An", 1}
              };
              return {0x30, 0x00, 0xFA, 0x06, 0x93, 0x00, mode_map.at(x)};


########################### CAN Nachrichten abfragen #################################################
#interval:
#  - interval: ${interval_time}
#    then:
#      if:
#        condition:
#          - lambda: "return id(interval_active);"
#        then:
#          - lambda: |-
#              sendRequest(id(can_bus));

canbus:
  - platform: esp32_can
    id: can_bus
    can_id: 0x680
    tx_pin: ${tx_pin}
    rx_pin: ${rx_pin}
    bit_rate: 20kbps

    on_frame:
      - can_id: 0 # listen to all messages
        can_id_mask: 0
        then:
          - lambda: |-
              struct timeval tv;
              gettimeofday(&tv, nullptr);
              ESP_LOGI("main", "mil: %d|now: %d|sec: %ld|usec: %d",
                millis(), id(homeassistant_time).now(), tv.tv_sec, tv.tv_usec);

              data_requests.handle(id(can_bus), can_id, x, millis());

time:
  - platform: homeassistant
    id: homeassistant_time
  - platform: sntp
    id: sntp_time
    on_time:
      - seconds: /1
        then:
          - lambda: |-
              //data_requests.sendNextPendingRequest(id(can_bus));
